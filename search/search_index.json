{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hi! I'm Jin Hang!","text":""},{"location":"#about-this-website","title":"About This Website","text":"<p>Welcome to my personal tech blog! This website serves as a repo. for my journey of learning computer science.  I'll also share resources that have helped me and things taht I discover interesting!. I hope my posts will inspire and assist you in your own learning adventure.</p> <p></p> <p>Quote</p> <p>The longest journey begins with a single step. </p>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li> <p> Perosonal Website</p> <p>This is my personal website!</p> <p> Personal Website</p> </li> <li> <p> Linkedin</p> <p>This is my Linkedin profile!</p> <p> Linkedin Profile</p> </li> <li> <p> Github</p> <p>This is my Github profile!</p> <p> Github</p> </li> </ul>"},{"location":"Project/","title":"Project","text":"<p>Note</p> <p>There are some projects I did during my study.</p> <ul> <li> <p></p> <p>Simulate a Git system and some of its command using basic data structure.</p> <p> More Details</p> </li> <li> <p></p> <p>My Solution and Notes of LeetCode Questions. (Undergoing)</p> <p> LeetCode Notes</p> </li> </ul> <p>New Project is on the way! \ud83d\udd25</p>"},{"location":"Project/Gitlet/","title":"Getlet","text":"<p>This is the design documentation of project Gitlet in CS61b</p>"},{"location":"Project/Gitlet/#before-start","title":"Before Start","text":"<p>You should make sure you are familiar with concepts below.</p> <p>Real Git distinguishes several different kinds of objects. For our purposes, the important ones are</p> Blob <p>The saved contents of files. Since Gitlet saves many versions of files, a single file might correspond to multiple blobs: each being tracked in a different commit.</p> Tree <p>Directory structures mapping names to references to blobs and other trees (subdirectories).</p> Commit <p>Combinations of </p> <ul> <li>log messages</li> <li>A reference to a tree</li> <li>References to parent commits</li> <li>Other metadata i.e. commit date, author, etc.</li> </ul> <p>The repository also maintains a mapping from branch heads to references to commits, so that certain important commits have symbolic names.</p> Git <p>You can refer to my Git Notes of Introduction to Git and GitHub by Google for more information.</p> <p>Below are the basic technical skill used in this project:</p> Serialize <p>A Java object is converted into a stream of bytes during serialization to be saved in a file or transferred over the internet. The serialized stream of bytes is transformed back into the original object during deserialization.</p> <ul> <li><code>static &lt;T extends Serializable&gt; T readObject(File file, Class&lt;T&gt; expectedClass)</code>: reads in a serializable object from a file.</li> <li><code>static void writeObject(File file, Serializable obj)</code>: writes a serializable object to a file</li> </ul> Io <p>There is a Tutorial og IO operation in Java. </p>"},{"location":"Project/Gitlet/#structure","title":"Structure","text":"<pre><code>.gitlet\n\u251c\u2500 HEAD\n\u251c\u2500 objects\n\u2502  \u251c\u2500 commit_1_id\n\u2502  \u251c\u2500 commit_2_id\n\u2502  \u2514\u2500 ...\n\u2514\u2500 ref\n   \u2514\u2500 heads\n      \u251c\u2500 master\n      \u2514\u2500 ...\n</code></pre>"},{"location":"Project/Gitlet/#classes-and-data-structures","title":"Classes and Data Structures","text":""},{"location":"Project/Gitlet/#blob","title":"Blob","text":""},{"location":"Project/Gitlet/#fields","title":"Fields","text":"<p><pre><code>private byte[] bytes;\nprivate String id;\nprivate String blobPath;\nprivate File src;\nprivate File blobSaveFileName;\n</code></pre> Every blob object has its own saved contents of files. We get the file name and contents(byte array) from <code>src</code> and write the blob itself to file <code>blobSaveFileName</code>.</p>"},{"location":"Project/Gitlet/#useful-functions","title":"Useful Functions","text":"<ul> <li><code>static byte[] readContents(File file)</code>: reads in a file as a byte array</li> <li><code>static File join(String first, String... others)</code>: joins together strings or files into a path.</li> <li><code>static String sha1(Object... vals)</code>: In the case of blobs, \u201csame content\u201d means the same file contents. </li> </ul>"},{"location":"Project/Gitlet/#commit","title":"Commit","text":""},{"location":"Project/Gitlet/#fields_1","title":"Fields","text":"<p><pre><code>private String message;\nprivate String id;\nprivate Date currentTime;\nprivate String timestamp;\nprivate List&lt;String&gt; parent;\nprivate Map&lt;String, String&gt; blobRef;\nprivate File commitSave;\n</code></pre> Remark</p> <ul> <li><code>id</code>: In the case of commits, it means the same metadata, the same mapping of names to references, and the same parent reference.</li> <li><code>currentTime</code>: For initial commit, set its date <code>January 1, 1970, 00:00:00 GMT</code>. For following commits, get current time.</li> <li><code>timestamp</code>: String generate from <code>currentTime</code>.</li> <li><code>parent</code>: Use a list to store id of the last previous commit.</li> <li><code>commitSave</code>: File get from commit <code>id</code>. We write commit object(deserializable) itself to this file.</li> </ul>"},{"location":"Project/Gitlet/#useful-functions_1","title":"Useful Functions","text":"<ul> <li><code>Date()</code>: Creates date object representing current date and time.</li> <li><code>Date(long milliseconds)</code>: Creates a date object for the given <code>milliseconds</code> since January 1, 1970, 00:00:00 GMT.</li> <li><code>SimpleDateFormat(String pattern)</code>: Constructs a SimpleDateFormat using the given <code>pattern</code> and the default date format symbols for the default <code>FORMAT</code> locale. Refer to Javadoc for more information.</li> </ul>"},{"location":"Project/Gitlet/#stage","title":"Stage","text":""},{"location":"Project/Gitlet/#fields_2","title":"Fields","text":"<p><pre><code>private Map&lt;String, String&gt; blobRef = new HashMap&lt;String, String&gt;();\n</code></pre> We implement a hash table storing reference of blob in add/remove stage.  <pre><code>Key: path\nValue: blob id\n</code></pre></p>"},{"location":"Project/Gitlet/#repository","title":"Repository","text":""},{"location":"Project/Gitlet/#fields_3","title":"Fields","text":"<p><pre><code>public static final File CWD = new File(System.getProperty(\"user.dir\"));\npublic static final File GITLET_DIR = join(CWD, \".gitlet\");\npublic static final File OBJECT_DIR = join(GITLET_DIR, \"objects\");\npublic static final File REF_DIR = join(GITLET_DIR, \"ref\");\npublic static final File HEADS_DIR = join(REF_DIR, \"heads\");\npublic static final File HEAD_FILE = join(GITLET_DIR, \"HEAD\");\npublic static final File ADDSTAGE_FILE = join(GITLET_DIR, \"add_stage\");\npublic static final File REMOVESTAGE_FILE = join(GITLET_DIR, \"remove_stage\");\nprivate static Commit commit; \nprivate static Stage addStage = new Stage();\nprivate static Stage removeStage = new Stage();\n</code></pre> Remarks</p> <ul> <li><code>private static Commit commit</code> current commit.</li> </ul>"},{"location":"Project/Gitlet/#commands","title":"Commands","text":""},{"location":"Project/Gitlet/#init","title":"<code>init</code>","text":"<ul> <li>Creates a new Gitlet version-control system in the current directory. </li> <li>This system will automatically start with one commit that contains no files and has the commit message <code>initial commit</code>.</li> </ul>"},{"location":"Project/Gitlet/#add","title":"<code>add</code>","text":"<p>Adds a copy of the file as it currently exists to the staging area.</p>"},{"location":"Project/Gitlet/#rm","title":"<code>rm</code>","text":"<p>There are two cases:</p> <ul> <li>Unstage the file if it is currently staged for addition.</li> <li>If the file is tracked in the current commit, stage it for removal, remove the file from the working directory if the user has not already done so.</li> </ul>"},{"location":"Project/Gitlet/#commit_1","title":"<code>commit</code>","text":"<p>Here\u2019s a picture of before-and-after commit after running following code:</p> <pre><code>add Blob4\nrm Blob1\ncommit \u201cadd and rm\u201d\n</code></pre> Before CommitAfter Commit <p></p> <p></p>"},{"location":"Project/Gitlet/#log","title":"<code>log</code>","text":"<ul> <li>Starting at the current head commit, display information about each commit backwards along the commit tree until the initial commit.</li> <li>For merge commits (those that have two parent commits), only display first parent's information </li> </ul>"},{"location":"Project/Gitlet/#global-log","title":"<code>global-log</code>","text":"<ul> <li>Displays information about all commits ever made</li> <li>The order of information does not matter.</li> </ul>"},{"location":"Project/Gitlet/#find","title":"<code>find</code>","text":"<p>Prints out the ids of all commits that have the given commit message</p>"},{"location":"Project/Gitlet/#status","title":"<code>status</code>","text":"<ul> <li>Displays what branches currently exist, and marks the current branch with a <code>*</code>. </li> <li>Displays what files have been staged for addition or removal.</li> </ul>"},{"location":"Project/Gitlet/#checkout","title":"<code>checkout</code>","text":"<p>There are three cases:</p> <ul> <li> <p><code>java gitlet.Main checkout -- [file name]</code></p> <ul> <li>After <code>commit</code>, there is <code>f.txt</code> in the working directory. Call the <code>checkout</code> command to recover the file. </li> <li>If the file currently tracked by commit contains <code>filename</code>, write it to the working directory</li> <li>If the file with the same name exists, overwrite it, if not, write it directly.</li> </ul> </li> <li> <p><code>java gitlet.Main checkout [commit id] -- [file name]</code></p> <ul> <li>Takes the version of the file as it exists in the commit with the given <code>id</code></li> <li>Puts it in the working directory, overwriting the version of the file that\u2019s already there if there is one.</li> </ul> </li> <li> <p><code>java gitlet.Main checkout [branch name]</code>: switch to <code>[branch name]</code></p> <p>Before checkout, HEAD points to the latest commit of the <code>master</code> branch. </p> <p>After checkout <code>other</code>, HEAD points to the latest commit of the <code>other</code> branch, and all the files in the working directory will become blob files included in <code>Commit4-B</code>. Then this file update process has three cases:</p> <ul> <li>Files tracked by both commit with same file name but different blobID (i.e. different content), the file in <code>Commit4-B</code> will replace the original file;</li> <li>Files whose file names are only tracked by <code>Commit4-A</code>, then these files will be deleted directly.</li> <li> <p>Files whose file names are only tracked by <code>Commit4-B</code>, then these files will be written directly to the working directory. </p> <ul> <li>If a file with the same name is already in the working directory when writing directly, it means that a new 1.txt file was added to the working directory before checkout without committed.</li> <li>In this situation, <code>gitlet</code> does not know whether to save the newly added file or take the file in <code>Commit4-B</code> and overwrite it, then, gitlet will report an error to avoid information loss.</li> </ul> </li> </ul> <p>Change HEAD to point to <code>Commit4-B</code> and then clear the cache area.</p> Before checkoutAfter checkout <p></p> <p></p> </li> </ul>"},{"location":"Project/Gitlet/#branch","title":"<code>branch</code>","text":"<ul> <li>Add a new file with <code>branchname</code> in <code>heads</code> dictionary, whose content is current <code>commitID</code>, without changing HEAD pointer.</li> <li>Only add a new branch.</li> </ul>"},{"location":"Project/Gitlet/#rm-branch","title":"<code>rm-branch</code>","text":"<ul> <li>Delete a branch by deleting <code>branchname</code> file in <code>heads</code> dictionary.</li> <li>Note that <code>branchname</code> should not be branch pointing by current <code>HEAD</code>.</li> </ul>"},{"location":"Project/Gitlet/#reset","title":"<code>reset</code>","text":"<ul> <li>Checks out all the files tracked by the given commit. Set <code>HEAD</code> pointing to specific commit id before file operation like that in <code>checkout branch</code>.</li> <li>Clear cache area finally.</li> </ul>"},{"location":"Project/Gitlet/#merge","title":"<code>merge</code>","text":"<p>Merge <code>branchname</code> to the current branch. Firstly we need to find split point, then we merge files.</p>"},{"location":"Project/Gitlet/#find-split-point","title":"Find Split Point","text":"<p>Split</p> <p>The split point is a latest common ancestor of the current and given branch heads.</p> <p>We can use BFS traverse the branch from back to front, using a hash map to store their depth and commit id until encounter initial commit.</p> <p>Then we can get commit map of our current branch and target branch. Now, we traverse two commit map and iterately update our split id and length to find the split point id. </p>"},{"location":"Project/Gitlet/#merge-files","title":"Merge Files","text":"<p>Firstly, we need to test two failure cases:</p> Fast ForwardAncestor <p>If split point commit is same with HEAD commit, which means <code>target branch</code> is in the same branch and forward than current branch, update HEAD to the head commit of <code>target branch</code>.</p> <p></p> <p>If split point commit is same with commit in <code>target commit</code>, which indicates <code>master</code> is in the same branch and behind master branch, thus we do not need to perform merge operation, simply output <code>Given branch is an ancestor of the current branch.</code> </p> <p></p> <p>Then, when we perform merge operation, there are eight cases. Note that in each figure blow, we assume commit with different color has a file <code>f.txt</code> with different content. A white commit does not have <code>f.txt</code>:</p> 12345678 <p>Any files that have been </p> <ul> <li>modified in the given branch since the split point</li> <li>not modified in the current branch since the split point should be changed to their versions in the given branch (checked out from the commit at the front of the given branch). </li> </ul> <p>These files should then all be automatically staged. </p> <p></p> <p>Any files that </p> <ul> <li>have been modified in the current branch </li> <li>but not in the given branch since the split point </li> </ul> <p>should stay as they are.</p> <p></p> <ul> <li> <p>Any files that have been modified in both the current and given branch in the same way (i.e., both files now have the same content or were both removed) are left unchanged by the merge. </p> </li> <li> <p>If a file was removed from both the current and given branch, but a file of the same name is present in the working directory, it is left alone and continues to be absent (not tracked nor staged) in the merge.</p> </li> </ul> <p></p> <p>Any files that were not present at the split point and are present only in the current branch should remain as they are.</p> <p></p> <p>Any files that were not present at the split point and are present only in the given branch should be checked out and staged.</p> <p></p> <p>Any files present at the split point, unmodified in the current branch, and absent in the given branch should be removed (and untracked).</p> <p></p> <p>Any files present at the split point, unmodified in the given branch, and absent in the current branch should remain absent.</p> <p></p> <p>Any files modified in different ways in the current and given branches are in conflict. </p> <p>\u201cModified in different ways\u201d can mean that the contents of both are changed and different from other, or the contents of one are changed and the other file is deleted, or the file was absent at the split point and has different contents in the given and current branches. </p> <p>In this case, replace the contents of the conflicted file with</p> <p></p>"},{"location":"Project/Gitlet/#reference","title":"Reference","text":"<ul> <li>Gitlet Project Document</li> </ul>"}]}